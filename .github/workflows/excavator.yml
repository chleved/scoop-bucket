name: Bucket Auto-Updater
on:
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:

jobs:
  excavate:
    name: Excavate & Smart Scan
    runs-on: windows-latest
    permissions:
      contents: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 1. Update manifest locally
      # This command AUTOMATICALLY writes the new version AND the new hash into the JSON file.
      - name: Install Scoop & Run Checkver
        shell: powershell
        run: |
          Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
          Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression
          ~/scoop/apps/scoop/current/bin/checkver.ps1 * -Dir bucket -Update

      # 2. Check if git detected any changes
      - name: Detect Changes
        id: diff
        shell: powershell
        run: |
          $changed = git diff --name-only bucket/
          if (-not $changed) {
            Write-Host "No version bumps detected."
            echo "updated=false" >> $env:GITHUB_OUTPUT
            exit 0
          }
          echo "updated=true" >> $env:GITHUB_OUTPUT
          $changedFiles = $changed -split "`n" | Where-Object { $_ -match '\.json$' }
          $changedJson = $changedFiles | ConvertTo-Json -Compress
          echo "changed_files=$changedJson" >> $env:GITHUB_OUTPUT

      # 3. Download the actual files to compute our own verification hash
      - name: Download Installers
        if: steps.diff.outputs.updated == 'true'
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path "$env:RUNNER_TEMP\vt-scan" -Force | Out-Null
          $files = '${{ steps.diff.outputs.changed_files }}' | ConvertFrom-Json
          
          foreach ($file in $files) {
            $json = Get-Content $file | ConvertFrom-Json
            
            # Extract URLs (handles 64bit/32bit/arm64 structures)
            $urls = @()
            if ($json.url) { $urls += @($json.url) }
            if ($json.architecture) {
                if ($json.architecture.'64bit'.url) { $urls += @($json.architecture.'64bit'.url) }
                if ($json.architecture.'32bit'.url) { $urls += @($json.architecture.'32bit'.url) }
            }
            
            foreach ($url in $urls) {
                $finalUrl = $url -replace '\$version', $json.version
                $filename = [System.IO.Path]::GetFileName(($finalUrl -split '\?')[0])
                Write-Host "Downloading $filename..."
                Invoke-WebRequest -Uri $finalUrl -OutFile "$env:RUNNER_TEMP\vt-scan\$filename" -UseBasicParsing
            }
          }

      # 4. SMART VT LOGIC: Check Hash -> Only Upload if Unknown
      - name: VirusTotal Smart Check
        if: steps.diff.outputs.updated == 'true'
        timeout-minutes: 60
        shell: powershell
        env:
          VT_API_KEY: ${{ secrets.VT_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $headers = @{ "x-apikey" = $env:VT_API_KEY }
          $files = Get-ChildItem -Path "$env:RUNNER_TEMP\vt-scan"
          $flagged = @()

          foreach ($file in $files) {
            # 1. Calculate the Hash of the downloaded file
            $hash = (Get-FileHash $file.FullName -Algorithm SHA256).Hash.ToLower()
            Write-Host "Checking $($file.Name)"
            Write-Host "SHA256: $hash"

            $analysisId = $null
            $stats = $null

            # 2. Ask VT: Do you know this hash?
            try {
              $response = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/files/$hash" -Headers $headers -ErrorAction Stop
              Write-Host ">> File is ALREADY KNOWN to VirusTotal."
              $stats = $response.data.attributes.last_analysis_stats
            } catch {
              # 3. If 404, it means VT has never seen this file. We must upload it.
              if ($_.Exception.Response.StatusCode -eq 404) {
                 Write-Host ">> File is NEW. Uploading to VirusTotal..."
                 
                 # Use curl for stable multipart upload
                 $uploadUrl = "https://www.virustotal.com/api/v3/files"
                 $jsonResponse = curl.exe --silent --request POST --url $uploadUrl --header "x-apikey: $env:VT_API_KEY" --form "file=@$($file.FullName)"
                 $uploadObj = $jsonResponse | ConvertFrom-Json
                 $analysisId = $uploadObj.data.id
              } else {
                 Write-Error "VT API Error: $($_.Exception.Message)"
                 exit 1
              }
            }

            # 4. If we uploaded it, we must wait for the result
            if ($analysisId) {
                Write-Host ">> Waiting for analysis to complete..."
                for ($i = 0; $i -lt 120; $i++) {
                    Start-Sleep -Seconds 30
                    $report = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/analyses/$analysisId" -Headers $headers
                    $status = $report.data.attributes.status
                    Write-Host "Attempt $($i+1)/120 - Status: $status"
                    
                    if ($status -eq 'completed') { 
                        $stats = $report.data.attributes.stats
                        break 
                    }
                    if ($i -eq 119) {
                        gh issue create --title "VT Alert: Timeout" --body "Timed out waiting for $hash" --label "security"
                        exit 1 
                    }
                }
            }

            # 5. Evaluate Verdict
            Write-Host ">> Verdict - Malicious: $($stats.malicious), Suspicious: $($stats.suspicious)"
            if ($stats.malicious -gt 0 -or $stats.suspicious -gt 0) {
               $flagged += "$($file.Name) (Malicious: $($stats.malicious))"
            }
          }

          # 6. Block Logic
          if ($flagged.Count -gt 0) {
            $body = "## VirusTotal Flagged Files`nThe update was blocked.`n`n" + ($flagged -join "`n")
            gh issue create --title "VT Alert: Malware Detected" --body "$body" --label "security"
            git reset --hard
            Write-Error "Malware detected. Aborting."
            exit 1
          }

      # 5. Commit & Push
      # The 'ely-prism.json' being committed HERE already contains the hash calculated by Step 1.
      - name: Commit and Push
        if: steps.diff.outputs.updated == 'true' && success()
        shell: powershell
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add bucket/
          
          if (git status --porcelain) {
            git commit -m "Auto-update manifests (VirusTotal Safe)"
            git push
            Write-Host "Success! Manifest updated with new version and hash."
          } else {
            Write-Host "No changes to commit."
          }